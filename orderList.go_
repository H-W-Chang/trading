package trading

import "sync"

type Order struct {
	OrderId string  `json:"orderID"`
	UserID  string  `json:"userID"`
	Item    string  `json:"item"`
	Op      int8    `json:"op"` //0 buy, 1 sell
	Volume  int     `json:"volume"`
	Price   float64 `json:"price"`
}
type OrderList struct {
	list          []Order
	totalVolume   int
	mux           sync.RWMutex
	inTransaction bool
}

func (ol *OrderList) AddOrder(order Order) {
	if !ol.inTransaction {
		ol.mux.Lock()
		defer ol.mux.Unlock()
	}
	ol.list = append(ol.list, order)
	ol.totalVolume += order.Volume
}
func (ol *OrderList) GetOrder(index int) Order {
	if !ol.inTransaction {
		ol.mux.RLock()
		defer ol.mux.RUnlock()
	}
	return ol.list[index]
}
func (ol *OrderList) UpdateOrder(index int, order Order) {
	if !ol.inTransaction {
		ol.mux.Lock()
		defer ol.mux.Unlock()
	}
	totalVolume := order.Volume - ol.list[index].Volume
	ol.list[index] = order
	ol.totalVolume += totalVolume
}
func (ol *OrderList) GetLength() int {
	if !ol.inTransaction {
		ol.mux.RLock()
		defer ol.mux.RUnlock()
	}
	return len(ol.list)
}
func (ol *OrderList) GetTotalVolume() int {
	if !ol.inTransaction {
		ol.mux.RLock()
		defer ol.mux.RUnlock()
	}
	return ol.totalVolume
}
func (ol *OrderList) PopFront() Order {
	if !ol.inTransaction {
		ol.mux.Lock()
		defer ol.mux.Unlock()
	}
	order := ol.list[0]
	ol.list = ol.list[1:]
	ol.totalVolume -= order.Volume
	return order
}
func (ol *OrderList) TransactionStart() {
	ol.mux.Lock()
	ol.inTransaction = true
}
func (ol *OrderList) TransactionStop() {
	ol.mux.Unlock()
	ol.inTransaction = false
}
