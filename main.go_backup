package main

import (
	// "trading/pkg/Interactor"
	"trading/pkg/server"
)

// var BuyOrderList map[float64]*OrderList
// var SellOrderList map[float64]*OrderList

//	func SendOrderFinished(order Order) {
//		return
//	}
//
//	func OrderPost(w http.ResponseWriter, r *http.Request) {
//		log.Println("OrderPost")
//		var order Order
//		if r.Method == "POST" {
//			err := json.NewDecoder(r.Body).Decode(&order)
//			if err != nil {
//				http.Error(w, err.Error(), http.StatusBadRequest)
//				return
//			}
//			//find match
//			switch order.Op {
//			case 0: //buy
//				if sol, ok := SellOrderList[order.Price]; ok {
//					if order.Volume <= sol.GetTotalVolume() { //matched
//						sol.TransactionStart()
//						for order.Volume > 0 {
//							o := sol.GetOrder(0)
//							if order.Volume >= o.Volume {
//								order.Volume -= o.Volume
//								sol.PopFront()
//								fmt.Printf("sell order dealed: %+v", o)
//								go SendOrderFinished(o)
//							} else {
//								o.Volume -= order.Volume
//								sol.UpdateOrder(0, o)
//								order.Volume = 0
//								fmt.Fprintf(w, "buy order dealed")
//								fmt.Println("buy order dealed")
//							}
//						}
//						sol.TransactionStop()
//					} else { //not matched
//						sol.AddOrder(order)
//						fmt.Println("add buy order to pending list")
//						fmt.Fprintf(w, "add buy order to pending list")
//					}
//				} else {
//					if _, ok := BuyOrderList[order.Price]; !ok {
//						BuyOrderList[order.Price] = &OrderList{}
//					}
//					BuyOrderList[order.Price].AddOrder(order)
//					fmt.Fprintf(w, "add buy order to pending list")
//					fmt.Println("add buy order to pending list")
//				}
//				break
//			case 1: //sell
//				if bol, ok := BuyOrderList[order.Price]; ok {
//					if order.Volume <= bol.GetTotalVolume() { //matched
//						bol.TransactionStart()
//						for order.Volume > 0 {
//							o := bol.GetOrder(0)
//							if order.Volume >= o.Volume {
//								order.Volume -= o.Volume
//								bol.PopFront()
//								fmt.Printf("buy order dealed: %+v", o)
//								go SendOrderFinished(o)
//							} else {
//								o.Volume -= order.Volume
//								bol.UpdateOrder(0, o)
//								order.Volume = 0
//								fmt.Fprintf(w, "sell order dealed")
//								fmt.Println("sell order dealed")
//							}
//						}
//						bol.TransactionStop()
//					} else { //not matched
//						bol.AddOrder(order)
//						fmt.Fprintf(w, "add sell order to pending list")
//						fmt.Println("add sell order to pending list")
//					}
//				} else {
//					if _, ok := SellOrderList[order.Price]; !ok {
//						SellOrderList[order.Price] = &OrderList{}
//					}
//					SellOrderList[order.Price].AddOrder(order)
//					fmt.Fprintf(w, "add sell order to pending list")
//					fmt.Println("add sell order to pending list")
//				}
//				break
//			default:
//				break
//			}
//		}
//	}
func main() {
	// BuyOrderList = make(map[float64]*OrderList)
	// SellOrderList = make(map[float64]*OrderList)
	// mux := http.NewServeMux()

	// mux.HandleFunc("/order", OrderPost)

	// http.ListenAndServe(":8080", mux)
	var server server.Server = &server.HttpServer{}
	server.Serve()
}
